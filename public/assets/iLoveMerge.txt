import { useEffect, useRef } from "react";
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";

gsap.registerPlugin(ScrollTrigger);

const AnimatedContent = ({
  children,
  distance = 100,
  direction = "vertical",
  reverse = false,
  duration = 0.8,
  ease = "power3.out",
  initialOpacity = 0,
  animateOpacity = true,
  scale = 1,
  threshold = 0.1,
  delay = 0,
  onComplete,
}) => {
  const contentRef = useRef(null);

  useEffect(() => {
    if (!contentRef.current) return;

    const animationProps = {
      duration,
      ease,
      delay,
      onComplete,
    };

    if (direction === "vertical") {
      animationProps.y = reverse ? distance : -distance;
      animationProps.y = 0;
    } else if (direction === "horizontal") {
      animationProps.x = reverse ? distance : -distance;
      animationProps.x = 0;
    }

    if (animateOpacity) {
      animationProps.opacity = 1;
    }

    if (scale !== 1) {
      animationProps.scale = 1;
    }

    gsap.fromTo(
      contentRef.current,
      {
        opacity: initialOpacity,
        ...(direction === "vertical" ? { y: reverse ? distance : -distance } : {}),
        ...(direction === "horizontal" ? { x: reverse ? distance : -distance } : {}),
        scale: scale,
      },
      {
        ...animationProps,
        scrollTrigger: {
          trigger: contentRef.current,
          start: `top ${100 - threshold * 100}%`,
          toggleActions: "play none none none",
        },
      }
    );
  }, [children, distance, direction, reverse, duration, ease, initialOpacity, animateOpacity, scale, threshold, delay, onComplete]);

  return <div ref={contentRef}>{children}</div>;
};

export default AnimatedContent;


import { useRef, useEffect } from "react";
import * as THREE from "three";

const vertexShader = `
  varying vec2 vUv;
  uniform float uTime;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform float uTime;
  uniform sampler2D uTexture;
  uniform vec2 uResolution;
  uniform float uAsciiFontSize;
  uniform bool uEnableWaves;

  // ASCII characters ordered by intensity
  const string asciiChars = " .:-=+*#%@";
  const int numChars = 10;

  void main() {
    vec2 uv = gl_FragCoord.xy / uResolution.xy;
    vec4 color = texture2D(uTexture, uv);

    // Convert to grayscale
    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));

    // Map grayscale to ASCII character index
    int charIndex = int(gray * float(numChars - 1));
    charIndex = clamp(charIndex, 0, numChars - 1);

    // Get the ASCII character from the string
    // This is a simplified representation, in a real shader you'd use a font texture
    // For this example, we'll just use the gray value to influence the color

    vec3 finalColor = color.rgb;

    if (uEnableWaves) {
      float wave = sin(uv.x * 10.0 + uTime * 2.0) * 0.1 + sin(uv.y * 10.0 + uTime * 2.0) * 0.1;
      finalColor += wave;
    }

    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

const ASCIIText = ({
  text = "hello_world",
  enableWaves = true,
  asciiFontSize = 8,
}) => {
  const mountRef = useRef(null);

  useEffect(() => {
    const currentMount = mountRef.current;
    if (!currentMount) return;

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(
      currentMount.clientWidth / -2,
      currentMount.clientWidth / 2,
      currentMount.clientHeight / 2,
      currentMount.clientHeight / -2,
      1,
      1000
    );
    camera.position.z = 1;

    const renderer = new THREE.WebGLRenderer({
      canvas: currentMount,
      antialias: true,
    });
    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const textureLoader = new THREE.TextureLoader();
    const textCanvas = document.createElement("canvas");
    const textCtx = textCanvas.getContext("2d");

    const updateTextTexture = () => {
      textCanvas.width = currentMount.clientWidth;
      textCanvas.height = currentMount.clientHeight;
      textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      textCtx.font = `${asciiFontSize * 2}px monospace`; // Render at higher resolution for better quality
      textCtx.fillStyle = "white";
      textCtx.textAlign = "center";
      textCtx.textBaseline = "middle";
      textCtx.fillText(text, textCanvas.width / 2, textCanvas.height / 2);
    };

    updateTextTexture();
    const textTexture = new THREE.CanvasTexture(textCanvas);

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTexture: { value: textTexture },
        uResolution: { value: new THREE.Vector2(currentMount.clientWidth, currentMount.clientHeight) },
        uTime: { value: 0.0 },
        uAsciiFontSize: { value: asciiFontSize },
        uEnableWaves: { value: enableWaves },
      },
    });

    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(currentMount.clientWidth, currentMount.clientHeight),
      material
    );
    scene.add(plane);

    const animate = () => {
      requestAnimationFrame(animate);
      material.uniforms.uTime.value += 0.01;
      renderer.render(scene, camera);
    };

    animate();

    const handleResize = () => {
      camera.left = currentMount.clientWidth / -2;
      camera.right = currentMount.clientWidth / 2;
      camera.top = currentMount.clientHeight / 2;
      camera.bottom = currentMount.clientHeight / -2;
      camera.updateProjectionMatrix();
      renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
      material.uniforms.uResolution.value.set(currentMount.clientWidth, currentMount.clientHeight);
      updateTextTexture();
      textTexture.needsUpdate = true;
    };

    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      renderer.dispose();
      textTexture.dispose();
      material.dispose();
      plane.geometry.dispose();
    };
  }, [text, enableWaves, asciiFontSize]);

  return <canvas ref={mountRef} style={{ width: "100%", height: "100vh" }} />;
};

export default ASCIIText;


import { motion, useInView, useAnimate } from 


motion, useInView, useAnimate } from 'framer-motion';
import { useEffect, useRef, useState, useMemo } from 'react';

const buildKeyframes = (from, steps) => {
  const keys = new Set([
    ...Object.keys(from),
    ...steps.flatMap((s) => Object.keys(s)),
  ]);

  const keyframes = {};
  keys.forEach((k) => {
    keyframes[k] = [from[k], ...steps.map((s) => s[k])];
  });
  return keyframes;
};

const BlurText = ({
  text = '',
  delay = 200,
  className = '',
  animateBy = 'words',
  direction = 'top',
  threshold = 0.1,
  rootMargin = '0px',
  animationFrom,
  animationTo,
  easing = (t) => t,
  onAnimationComplete,
  stepDuration = 0.35,
}) => {
  const elements = animateBy === 'words' ? text.split(' ') : text.split('');
  const [inView, setInView] = useState(false);
  const ref = useRef(null);

  useEffect(() => {
    if (!ref.current) return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.unobserve(ref.current);
        }
      },
      { threshold, rootMargin }
    );
    observer.observe(ref.current);
    return () => observer.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [threshold, rootMargin]);

  const defaultFrom = useMemo(
    () =>
      direction === 'top'
        ? { filter: 'blur(10px)', opacity: 0, y: -50 }
        : { filter: 'blur(10px)', opacity: 0, y: 50 },
    [direction]
  );

  const defaultTo = useMemo(
    () => [
      {
        filter: 'blur(5px)',
        opacity: 0.5,
        y: direction === 'top' ? 5 : -5,
      },
      { filter: 'blur(0px)', opacity: 1, y: 0 },
    ],
    [direction]
  );

  const fromSnapshot = animationFrom ?? defaultFrom;
  const toSnapshots = animationTo ?? defaultTo;

  const stepCount = toSnapshots.length + 1;
  const totalDuration = stepDuration * (stepCount - 1);
  const times = Array.from({ length: stepCount }, (_, i) =>
    stepCount === 1 ? 0 : i / (stepCount - 1)
  );

  return (
    <p
      ref={ref}
      className={className}
      style={{ display: 'flex', flexWrap: 'wrap' }}
    >
      {elements.map((segment, index) => {
        const animateKeyframes = buildKeyframes(fromSnapshot, toSnapshots);

        const spanTransition = {
          duration: totalDuration,
          times,
          delay: (index * delay) / 1000,
        };
        (spanTransition).ease = easing;

        return (
          <motion.span
            className="inline-block will-change-[transform,filter,opacity]"
            key={index}
            initial={fromSnapshot}
            animate={inView ? animateKeyframes : fromSnapshot}
            transition={spanTransition}
            onAnimationComplete={
              index === elements.length - 1 ? onAnimationComplete : undefined
            }
          >
            {segment === ' ' ? '\u00A0' : segment}
            {animateBy === 'words' && index < elements.length - 1 && '\u00A0'}
          </motion.span>
        );
      })}
    </p>
  );
};

export default BlurText;


import { useEffect } from "react";
import { motion, useAnimation, useMotionValue } from "motion/react";
import "./CircularText.css";

const CircularText = ({
  text = "",
  spinDuration = 20,
  onHover,
  className = "",
}) => {
  const radius = 100;
  const circumference = 2 * Math.PI * radius;
  const characters = text.split("");
  const charAngle = 360 / characters.length;

  const rotate = useMotionValue(0);
  const controls = useAnimation();

  useEffect(() => {
    controls.start({
      rotate: 360,
      transition: { duration: spinDuration, ease: "linear", repeat: Infinity },
    });
  }, [controls, spinDuration]);

  const handleHoverStart = () => {
    if (onHover === "slowDown") {
      controls.stop();
      controls.start({
        rotate: rotate.get() + 360,
        transition: { duration: spinDuration * 2, ease: "linear", repeat: Infinity },
      });
    } else if (onHover === "speedUp") {
      controls.stop();
      controls.start({
        rotate: rotate.get() + 360,
        transition: { duration: spinDuration / 2, ease: "linear", repeat: Infinity },
      });
    } else if (onHover === "pause") {
      controls.stop();
    } else if (onHover === "goBonkers") {
      controls.stop();
      controls.start({
        rotate: [rotate.get(), rotate.get() + 360, rotate.get() + 720],
        transition: { duration: 0.5, ease: "easeOut", repeat: Infinity, repeatType: "mirror" },
      });
    }
  };

  const handleHoverEnd = () => {
    if (onHover) {
      controls.stop();
      controls.start({
        rotate: rotate.get() + 360,
        transition: { duration: spinDuration, ease: "linear", repeat: Infinity },
      });
    }
  };

  return (
    <motion.div
      className={`circular-text-container ${className}`}
      style={{ width: radius * 2, height: radius * 2 }}
      onHoverStart={handleHoverStart}
      onHoverEnd={handleHoverEnd}
    >
      <motion.div className="circular-text" style={{ rotate }}>
        {characters.map((char, i) => (
          <motion.span
            key={i}
            className="circular-text-char"
            style={{
              position: "absolute",
              transformOrigin: `0 ${radius}px`,
              left: "50%",
              top: "0",
              height: "50%",
              transform: `rotate(${i * charAngle}deg)`,
            }}
          >
            {char}
          </motion.span>
        ))}
      </motion.div>
    </motion.div>
  );
};

export default CircularText;


Split Text
Blur Text
Circular Text
Text Type
Shiny Text
Text Pressure
Curved Loop
Fuzzy Text
Gradient Text
Text Trail
Falling Text
Text Cursor
Decrypted Text
True Focus
Scroll Float
Scroll Reveal
ASCII Text


import { useEffect, useRef } from "react";
import { useInView, useMotionValue, useSpring } from "framer-motion";

const CountUp = ({
  to,
  from = 0,
  direction = "up",
  delay = 0,
  duration = 2,
  className = "",
  startWhen = true,
  separator = "",
  onStart,
  onEnd,
}) => {
  const ref = useRef(null);
  const inView = useInView(ref, { once: true });
  const motionValue = useMotionValue(from);
  const spring = useSpring(motionValue, {
    damping: 100,
    stiffness: 100,
    duration: duration * 1000, // Convert to milliseconds
  });

  useEffect(() => {
    if (inView && startWhen) {
      const targetValue = direction === "up" ? to : from;
      const initialValue = direction === "up" ? from : to;

      motionValue.set(initialValue);

      const timeout = setTimeout(() => {
        if (onStart) onStart();
        motionValue.set(targetValue);
      }, delay * 1000);

      const unsubscribe = spring.on("change", (latest) => {
        if (latest === targetValue) {
          if (onEnd) onEnd();
          unsubscribe();
        }
      });

      return () => {
        clearTimeout(timeout);
        unsubscribe();
      };
    }
  }, [inView, startWhen, to, from, direction, delay, motionValue, spring, onStart, onEnd]);

  useEffect(() => {
    const unsubscribe = spring.on("change", (latest) => {
      if (ref.current) {
        ref.current.textContent = latest.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, separator);
      }
    });

    return unsubscribe;
  }, [spring, separator]);

  return <span ref={ref} className={className} />;
};

export default CountUp;


import { useRef, useEffect } from "react";
import { gsap } from "gsap";
import { MotionPathPlugin } from "gsap/MotionPathPlugin";
import { Draggable } from "gsap/Draggable";

gsap.registerPlugin(MotionPathPlugin, Draggable);

const CurvedLoop = ({
  marqueeText = "",
  speed = 2,
  className = "",
  curveAmount = 400,
  direction = "left",
  interactive = true,
}) => {
  const pathRef = useRef(null);
  const textRef = useRef(null);

  useEffect(() => {
    const path = pathRef.current;
    const text = textRef.current;

    if (!path || !text) return;

    const pathLength = path.getTotalLength();

    gsap.set(text, {
      xPercent: -50,
      yPercent: -50,
      transformOrigin: "50% 50%",
    });

    const animation = gsap.to(text, {
      duration: speed,
      ease: "none",
      repeat: -1,
      motionPath: {
        path: path,
        align: path,
        alignOrigin: [0.5, 0.5],
        autoRotate: true,
        start: direction === "left" ? 1 : 0,
        end: direction === "left" ? 0 : 1,
      },
    });

    if (interactive) {
      Draggable.create(text, {
        type: "x,y",
        onDrag: function () {
          const progress = MotionPathPlugin.get  (path, this.x, this.y);
          animation.progress(progress);
        },
      });
    }

    return () => {
      animation.kill();
      if (interactive) {
        Draggable.get(text)?.kill();
      }
    };
  }, [marqueeText, speed, curveAmount, direction, interactive]);

  return (
    <div className={`curved-loop-container ${className}`}>
      <svg
        viewBox="0 0 1000 200"
        preserveAspectRatio="xMidYMid meet"
        style={{ width: "100%", height: "auto" }}
      >
        <path
          ref={pathRef}
          d={`M0 100 C250 ${100 - curveAmount}, 750 ${100 - curveAmount}, 1000 100`}
          fill="none"
          stroke="transparent"
        />
      </svg>
      <div
        ref={textRef}
        className="curved-loop-text"
        style={{ position: "absolute", whiteSpace: "nowrap" }}
      >
        {marqueeText}
      </div>
    </div>
  );
};

export default CurvedLoop;


import { useState, useEffect, useRef, useCallback } from "react";
import { motion, useAnimate } from "framer-motion";

const DecryptedText = ({
  text = "",
  speed = 50,
  maxIterations = 10,
  sequential = false,
  revealDirection = "start",
  useOriginalCharsOnly = false,
  className = "",
  parentClassName = "",
  encryptedClassName = "",
  animateOn = "hover",
}) => {
  const [displayedText, setDisplayedText] = useState(text);
  const [scope, animate] = useAnimate();
  const intervalRef = useRef(null);
  const iterationCount = useRef(0);
  const revealIndex = useRef(0);
  const isAnimating = useRef(false);

  const chars = useOriginalCharsOnly
    ? text.split("")
    : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-+=\\\/{}[]";

  const getRandomChar = useCallback(() => {
    return chars[Math.floor(Math.random() * chars.length)];
  }, [chars]);

  const scrambleText = useCallback(() => {
    setDisplayedText((prevText) => {
      return prevText
        .split("")
        .map((char, index) => {
          if (sequential) {
            if (revealDirection === "start" && index < revealIndex.current) {
              return text[index];
            } else if (
              revealDirection === "end" &&
              index >= text.length - revealIndex.current
            ) {
              return text[index];
            } else if (
              revealDirection === "center" &&
              (index < revealIndex.current ||
                index >= text.length - revealIndex.current)
            ) {
              return text[index];
            }
          }
          return getRandomChar();
        })
        .join("");
    });
  }, [text, getRandomChar, sequential, revealDirection]);

  const startAnimation = useCallback(() => {
    if (isAnimating.current) return;
    isAnimating.current = true;
    iterationCount.current = 0;
    revealIndex.current = 0;

    intervalRef.current = setInterval(() => {
      if (sequential) {
        if (revealIndex.current < text.length) {
          revealIndex.current++;
        } else {
          clearInterval(intervalRef.current);
          isAnimating.current = false;
        }
      } else {
        if (iterationCount.current < maxIterations) {
          iterationCount.current++;
        } else {
          clearInterval(intervalRef.current);
          setDisplayedText(text);
          isAnimating.current = false;
        }
      }
      scrambleText();
    }, speed);
  }, [text, speed, maxIterations, sequential, scrambleText]);

  const resetAnimation = useCallback(() => {
    clearInterval(intervalRef.current);
    isAnimating.current = false;
    setDisplayedText(text);
  }, [text]);

  useEffect(() => {
    if (animateOn === "view") {
      const observer = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            startAnimation();
            observer.disconnect();
          }
        },
        { threshold: 0.5 }
      );
      if (scope.current) {
        observer.observe(scope.current);
      }
      return () => {
        observer.disconnect();
        resetAnimation();
      };
    } else if (animateOn === "hover") {
      const element = scope.current;
      if (element) {
        element.addEventListener("mouseenter", startAnimation);
        element.addEventListener("mouseleave", resetAnimation);
      }
      return () => {
        if (element) {
          element.removeEventListener("mouseenter", startAnimation);
          element.removeEventListener("mouseleave", resetAnimation);
        }
        resetAnimation();
      };
    }
  }, [animateOn, startAnimation, resetAnimation, scope]);

  return (
    <motion.div ref={scope} className={`decrypted-text-container ${parentClassName}`}>
      {displayedText.split("").map((char, index) => (
        <span
          key={index}
          className={`decrypted-char ${char === text[index] ? className : encryptedClassName}`}
        >
          {char}
        </span>
      ))}
    </motion.div>
  );
};

export default DecryptedText;


import React, { useRef, useEffect } from "react";
import { motion, useMotionValue, useSpring, useTransform } from "framer-motion";

const ElectricBorder = ({
  children,
  color = "#5227FF",
  speed = 1,
  chaos = 1,
  thickness = 2,
  className = "",
  style = {},
}) => {
  const svgRef = useRef(null);
  const filterRef = useRef(null);
  const feTurbulenceRef = useRef(null);

  const baseFrequency = useMotionValue(0.01);
  const numOctaves = useMotionValue(1);
  const seed = useMotionValue(0);

  const springConfig = {
    damping: 10,
    stiffness: 100,
    mass: 0.1,
  };

  const animatedBaseFrequency = useSpring(baseFrequency, springConfig);
  const animatedNumOctaves = useSpring(numOctaves, springConfig);
  const animatedSeed = useSpring(seed, springConfig);

  useEffect(() => {
    const animateFilter = () => {
      baseFrequency.set(0.01 + Math.random() * 0.02 * chaos);
      numOctaves.set(1 + Math.random() * 2 * chaos);
      seed.set(Math.random() * 1000);

      requestAnimationFrame(animateFilter);
    };

    const animationFrame = requestAnimationFrame(animateFilter);

    return () => cancelAnimationFrame(animationFrame);
  }, [baseFrequency, numOctaves, seed, chaos]);

  useEffect(() => {
    if (feTurbulenceRef.current) {
      const unsubscribeBaseFrequency = animatedBaseFrequency.onChange((v) => {
        feTurbulenceRef.current.setAttribute("baseFrequency", v);
      });
      const unsubscribeNumOctaves = animatedNumOctaves.onChange((v) => {
        feTurbulenceRef.current.setAttribute("numOctaves", v);
      });
      const unsubscribeSeed = animatedSeed.onChange((v) => {
        feTurbulenceRef.current.setAttribute("seed", v);
      });

      return () => {
        unsubscribeBaseFrequency();
        unsubscribeNumOctaves();
        unsubscribeSeed();
      };
    }
  }, [animatedBaseFrequency, animatedNumOctaves, animatedSeed]);

  return (
    <div
      className={`electric-border-container ${className}`}
      style={{
        position: "relative",
        display: "inline-block",
        ...style,
      }}
    >
      <svg
        ref={svgRef}
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
        }}
      >
        <defs>
          <filter id="electric-border-filter" ref={filterRef}>
            <feTurbulence
              ref={feTurbulenceRef}
              type="fractalNoise"
              baseFrequency="0.01"
              numOctaves="1"
              seed="0"
              stitchTiles="stitch"
            />
            <feDiffuseLighting
              in="noise"
              lighting-color={color}
              surfaceScale="3"
            >
              <feDistantLight azimuth="225" elevation="60" />
            </feDiffuseLighting>
            <feBlend in="SourceGraphic" in2="lighting" mode="screen" />
            <feMorphology operator="dilate" radius={thickness} />
            <feGaussianBlur stdDeviation="2" result="coloredBlur" />
            <feMerge>
              <feMergeNode in="coloredBlur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <rect
          x="0"
          y="0"
          width="100%"
          height="100%"
          fill="none"
          stroke={color}
          strokeWidth={thickness}
          filter="url(#electric-border-filter)"
        />
      </svg>
      {children}
    </div>
  );
};

export default ElectricBorder;


import { useRef, useEffect, useState } from "react";
import { motion } from "framer-motion";

const FadeContent = ({
  children,
  blur = false,
  duration = 1000,
  easing = "ease-out",
  delay = 0,
  threshold = 0.1,
  initialOpacity = 0,
  className = "",
}) => {
  const [inView, setInView] = useState(false);
  const ref = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.disconnect();
        }
      },
      { threshold: threshold }
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => {
      if (ref.current) {
        observer.unobserve(ref.current);
      }
    };
  }, [threshold]);

  return (
    <motion.div
      ref={ref}
      initial={{ opacity: initialOpacity, filter: blur ? `blur(5px)` : "none" }}
      animate={inView ? { opacity: 1, filter: "blur(0px)" } : {}}
      transition={{ duration: duration / 1000, ease: easing, delay: delay / 1000 }}
      className={className}
    >
      {children}
    </motion.div>
  );
};

export default FadeContent;


import { useEffect, useRef, useState, useCallback } from "react";
import Matter from "matter-js";

const FallingText = ({
  text = "",
  highlightWords = [],
  highlightClass = "highlighted",
  trigger = "click",
  backgroundColor = "transparent",
  wireframes = false,
  gravity = 1,
  mouseConstraintStiffness = 0.2,
  fontSize = "1rem",
  wordSpacing = "2px",
}) => {
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const engineRef = useRef(null);
  const renderRef = useRef(null);
  const mouseRef = useRef(null);
  const mouseConstraintRef = useRef(null);
  const [isTriggered, setIsTriggered] = useState(false);

  const createPhysicsWorld = useCallback(() => {
    const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite,
      Mouse = Matter.Mouse,
      MouseConstraint = Matter.MouseConstraint;

    const engine = Engine.create();
    engine.gravity.y = gravity;
    engineRef.current = engine;

    const render = Render.create({
      element: containerRef.current,
      engine: engine,
      canvas: canvasRef.current,
      options: {
        width: containerRef.current.clientWidth,
        height: containerRef.current.clientHeight,
        background: backgroundColor,
        wireframes: wireframes,
      },
    });
    renderRef.current = render;

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    const mouse = Mouse.create(render.canvas);
    mouseRef.current = mouse;
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: mouseConstraintStiffness,
        render: {
          visible: false,
        },
      },
    });
    mouseConstraintRef.current = mouseConstraint;
    Composite.add(engine.world, mouseConstraint);

    render.mouse = mouse;

    // Add boundaries
    const ground = Bodies.rectangle(
      render.options.width / 2,
      render.options.height + 25,
      render.options.width * 2,
      50,
      { isStatic: true }
    );
    const leftWall = Bodies.rectangle(
      -25,
      render.options.height / 2,
      50,
      render.options.height * 2,
      { isStatic: true }
    );
    const rightWall = Bodies.rectangle(
      render.options.width + 25,
      render.options.height / 2,
      50,
      render.options.height * 2,
      { isStatic: true }
    );
    const ceiling = Bodies.rectangle(
      render.options.width / 2,
      -25,
      render.options.width * 2,
      50,
      { isStatic: true }
    );

    Composite.add(engine.world, [ground, leftWall, rightWall, ceiling]);

    return () => {
      Render.stop(render);
      Runner.stop(runner);
      Engine.clear(engine);
      render.canvas.remove();
      render.textures = {};
    };
  }, [backgroundColor, wireframes, gravity, mouseConstraintStiffness]);

  const addTextToWorld = useCallback(() => {
    if (!engineRef.current || !renderRef.current) return;

    const words = text.split(" ");
    let currentX = 50;
    let currentY = 50;

    words.forEach((word, wordIndex) => {
      const isHighlighted = highlightWords.some((hw) =>
        word.toLowerCase().includes(hw.toLowerCase())
      );
      const wordElement = document.createElement("span");
      wordElement.innerText = word + " ";
      wordElement.style.fontSize = fontSize;
      wordElement.style.wordSpacing = wordSpacing;
      wordElement.style.whiteSpace = "nowrap";
      if (isHighlighted) {
        wordElement.classList.add(highlightClass);
      }
      containerRef.current.appendChild(wordElement);

      const wordWidth = wordElement.offsetWidth;
      const wordHeight = wordElement.offsetHeight;

      const wordBody = Bodies.rectangle(
        currentX + wordWidth / 2,
        currentY + wordHeight / 2,
        wordWidth,
        wordHeight,
        {
          restitution: 0.5,
          friction: 0.1,
          density: 0.001,
          render: {
            fillStyle: "transparent",
            strokeStyle: "transparent",
          },
        }
      );

      Composite.add(engineRef.current.world, wordBody);

      // Store the DOM element reference on the body for rendering
      wordBody.render.sprite = {
        texture: `data:image/svg+xml;base64,${btoa(
          `<svg xmlns="http://www.w3.org/2000/svg" width="${wordWidth}" height="${wordHeight}">
            <foreignObject width="100%" height="100%">
              <div xmlns="http://www.w3.org/1999/xhtml" style="font-size:${fontSize}; word-spacing:${wordSpacing}; white-space:nowrap; color: currentColor; ${isHighlighted ? `class=\"${highlightClass}\"` : ""}">
                ${word}
              </div>
            </foreignObject>
          </svg>`
        )}`,
      };

      currentX += wordWidth;
      if (currentX > renderRef.current.options.width - 100) {
        currentX = 50;
        currentY += wordHeight + 10;
      }
    });
  }, [text, highlightWords, highlightClass, fontSize, wordSpacing]);

  useEffect(() => {
    const cleanup = createPhysicsWorld();
    addTextToWorld();

    const handleTrigger = () => {
      setIsTriggered(true);
      // Apply a force to all bodies to make them fall
      Matter.Composite.allBodies(engineRef.current.world).forEach((body) => {
        if (!body.isStatic) {
          Matter.Body.applyForce(
            body,
            body.position,
            { x: (Math.random() - 0.5) * 0.05, y: (Math.random() * 0.05) + 0.02 }
          );
        }
      });
    };

    if (trigger === "click") {
      containerRef.current.addEventListener("click", handleTrigger);
    } else if (trigger === "hover") {
      containerRef.current.addEventListener("mouseenter", handleTrigger);
    } else if (trigger === "auto") {
      handleTrigger();
    } else if (trigger === "scroll") {
      const observer = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            handleTrigger();
            observer.disconnect();
          }
        },
        { threshold: 0.5 }
      );
      observer.observe(containerRef.current);
    }

    return () => {
      cleanup();
      if (trigger === "click") {
        containerRef.current.removeEventListener("click", handleTrigger);
      } else if (trigger === "hover") {
        containerRef.current.removeEventListener("mouseenter", handleTrigger);
      }
    };
  }, [createPhysicsWorld, addTextToWorld, trigger]);

  return (
    <div
      ref={containerRef}
      style={{
        position: "relative",
        width: "100%",
        height: "100vh",
        overflow: "hidden",
      }}
    >
      <canvas ref={canvasRef} />
    </div>
  );
};

export default FallingText;


import React, { useEffect, useRef } from "react";

const FuzzyText = ({
  children,
  fontSize = "clamp(2rem, 8vw, 8rem)",
  fontWeight = 900,
  fontFamily = "inherit",
  color = "#fff",
  enableHover = true,
  baseIntensity = 0.18,
  hoverIntensity = 0.5,
}) => {
  const canvasRef = useRef(null);
  const animationFrameId = useRef(null);
  const currentIntensity = useRef(baseIntensity);

  const animate = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.offsetWidth * dpr;
    canvas.height = canvas.offsetHeight * dpr;
    ctx.scale(dpr, dpr);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
    ctx.fillStyle = color;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const textX = canvas.offsetWidth / 2;
    const textY = canvas.offsetHeight / 2;

    ctx.fillText(children, textX, textY);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;

    for (let i = 0; i < pixels.length; i += 4) {
      if (pixels[i + 3] !== 0) {
        // Only affect non-transparent pixels
        const offset = (Math.random() - 0.5) * 255 * currentIntensity.current;
        pixels[i] = pixels[i] + offset;
        pixels[i + 1] = pixels[i + 1] + offset;
        pixels[i + 2] = pixels[i + 2] + offset;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    animationFrameId.current = requestAnimationFrame(animate);
  };

  useEffect(() => {
    if (canvasRef.current) {
      animationFrameId.current = requestAnimationFrame(animate);
    }

    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [children, fontSize, fontWeight, fontFamily, color]);

  const handleMouseEnter = () => {
    if (enableHover) {
      currentIntensity.current = hoverIntensity;
    }
  };

  const handleMouseLeave = () => {
    if (enableHover) {
      currentIntensity.current = baseIntensity;
    }
  };

  return (
    <div
      style={{
        position: "relative",
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <canvas
        ref={canvasRef}
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
        }}
      />
    </div>
  );
};

export default FuzzyText;


import React from "react";
import "./GlitchText.css";

const GlitchText = ({
  children,
  speed = 1,
  enableShadows = true,
  enableOnHover = false,
  className = "",
}) => {
  const glitchStyle = {
    "--speed": speed,
  };

  const classNames = `glitch-text ${className} ${enableShadows ? "with-shadows" : ""} ${enableOnHover ? "glitch-on-hover" : ""}`;

  return (
    <span className={classNames} style={glitchStyle}>
      {children}
      <span className="glitch-text__clone" aria-hidden="true">
        {children}
      </span>
      <span className="glitch-text__clone" aria-hidden="true">
        {children}
      </span>
    </span>
  );
};

export default GlitchText;


import "./GradientText.css";

export default function GradientText({
  children,
  className = "",
  colors = ["#40ffaa", "#4079ff", "#40ffaa", "#4079ff", "#40ffaa"],
  animationSpeed = 8,
  showBorder = false,
}) {
  const gradientStyle = {
    backgroundImage: `linear-gradient(to right, ${colors.join(", ")})`,
  };

  return (
    <span
      className={`gradient-text ${className}`}
      style={gradientStyle}
    >
      {children}
      {showBorder && (
        <span className="gradient-text-border" style={gradientStyle} />
      )}
    </span>
  );
}


import React, { useRef, useEffect, useState, useCallback } from "react";
import { motion, useScroll, useTransform } from "framer-motion";
import { createPortal } from "react-dom";
import * as math from "mathjs";

const GradualBlur = ({
  children,
  position = "bottom",
  strength = 2,
  height = "6rem",
  width,
  divCount = 5,
  exponential = false,
  curve = "linear",
  opacity = 1,
  animated = false,
  duration = "0.3s",
  easing = "ease-out",
  hoverIntensity,
  target = "parent",
  preset,
  responsive = false,
  zIndex = 1000,
  onAnimationComplete,
  className,
  style,
}) => {
  const containerRef = useRef(null);
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });
  const [isHovered, setIsHovered] = useState(false);
  const [isAnimatedIn, setIsAnimatedIn] = useState(false);

  const { scrollYProgress } = useScroll({
    target: containerRef,
    offset: ["start end", "end start"],
  });

  const getBlurValue = useCallback(
    (i) => {
      let progress = i / (divCount - 1);
      if (curve === "bezier") {
        progress = math.evaluate(`bezier(${progress}, 0.42, 0, 0.58, 1)`);
      } else if (curve === "ease-in") {
        progress = math.evaluate(`easeIn(${progress})`);
      }

      const currentStrength =
        strength * (isHovered && hoverIntensity ? hoverIntensity : 1);

      return exponential
        ? currentStrength * Math.exp(progress * 2)
        : currentStrength * progress;
    },
    [divCount, curve, strength, isHovered, hoverIntensity, exponential]
  );

  const getOpacityValue = useCallback(
    (i) => {
      const progress = i / (divCount - 1);
      return opacity * progress;
    },
    [divCount, opacity]
  );

  const getContainerStyle = useCallback(() => {
    const baseStyle = {
      position: target === "parent" ? "absolute" : "fixed",
      pointerEvents: "none",
      zIndex: target === "page" ? zIndex + 100 : zIndex,
    };

    if (position === "top") {
      return {
        ...baseStyle,
        top: 0,
        left: 0,
        width: width || "100%",
        height: height,
      };
    } else if (position === "bottom") {
      return {
        ...baseStyle,
        bottom: 0,
        left: 0,
        width: width || "100%",
        height: height,
      };
    } else if (position === "left") {
      return {
        ...baseStyle,
        top: 0,
        left: 0,
        height: height || "100%",
        width: width || height,
      };
    } else if (position === "right") {
      return {
        ...baseStyle,
        top: 0,
        right: 0,
        height: height || "100%",
        width: width || height,
      };
    }
    return baseStyle;
  }, [position, height, width, target, zIndex]);

  useEffect(() => {
    if (containerRef.current) {
      const updateSize = () => {
        setContainerSize({
          width: containerRef.current.offsetWidth,
          height: containerRef.current.offsetHeight,
        });
      };
      updateSize();
      if (responsive) {
        window.addEventListener("resize", updateSize);
        return () => window.removeEventListener("resize", updateSize);
      }
    }
  }, [responsive]);

  const blurLayers = useMemo(() => {
    return Array.from({ length: divCount }).map((_, i) => {
      const blurValue = getBlurValue(i);
      const opacityValue = getOpacityValue(i);

      const layerStyle = {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        backdropFilter: `blur(${blurValue}px)`,
        opacity: opacityValue,
      };

      return <div key={i} style={layerStyle} />;
    });
  }, [divCount, getBlurValue, getOpacityValue]);

  const variants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { duration: parseFloat(duration), ease: easing } },
  };

  useEffect(() => {
    if (animated === "scroll") {
      const unsubscribe = scrollYProgress.on("change", (latest) => {
        if (latest > 0 && !isAnimatedIn) {
          setIsAnimatedIn(true);
          if (onAnimationComplete) onAnimationComplete();
        }
      });
      return () => unsubscribe();
    } else if (animated === true && !isAnimatedIn) {
      setIsAnimatedIn(true);
      if (onAnimationComplete) onAnimationComplete();
    }
  }, [animated, scrollYProgress, isAnimatedIn, onAnimationComplete]);

  const content = (
    <motion.div
      ref={containerRef}
      className={`gradual-blur-container ${className}`}
      style={{ ...getContainerStyle(), ...style }}
      onMouseEnter={() => hoverIntensity && setIsHovered(true)}
      onMouseLeave={() => hoverIntensity && setIsHovered(false)}
      initial={animated ? "hidden" : "visible"}
      animate={isAnimatedIn ? "visible" : "hidden"}
      variants={variants}
    >
      {blurLayers}
      {children}
    </motion.div>
  );

  return target === "page" ? createPortal(content, document.body) : content;
};

export default GradualBlur;


import React, { useRef, useState, useEffect } from "react";
import { gsap } from "gsap";

const PixelTransition = ({
  firstContent,
  secondContent,
  gridSize = 7,
  pixelColor = "currentColor",
  animationStepDuration = 0.3,
  aspectRatio = "100%",
  className = "",
  style = {},
}) => {
  const containerRef = useRef(null);
  const [isHovered, setIsHovered] = useState(false);
  const [isClicked, setIsClicked] = useState(false);

  const handleInteraction = () => {
    if (containerRef.current) {
      const pixels = Array.from(containerRef.current.children).filter((child) =>
        child.classList.contains("pixel-transition-pixel")
      );

      const shuffledPixels = gsap.utils.shuffle(pixels);

      gsap.to(shuffledPixels, {
        backgroundColor: pixelColor,
        duration: animationStepDuration,
        stagger: {
          each: 0.02,
          from: "random",
        },
        onComplete: () => {
          setIsHovered((prev) => !prev);
          setIsClicked((prev) => !prev);
          gsap.to(shuffledPixels, {
            backgroundColor: "transparent",
            duration: animationStepDuration,
            stagger: {
              each: 0.02,
              from: "random",
            },
            delay: 0.5, // Delay before pixels disappear
          });
        },
      });
    }
  };

  return (
    <div
      ref={containerRef}
      className={`pixel-transition-container ${className}`}
      style={{
        position: "relative",
        width: "100%",
        paddingTop: aspectRatio,
        overflow: "hidden",
        display: "grid",
        gridTemplateColumns: `repeat(${gridSize}, 1fr)`,
        gridTemplateRows: `repeat(${gridSize}, 1fr)`,
        ...style,
      }}
      onMouseEnter={handleInteraction}
      onClick={handleInteraction}
    >
      <div
        className="pixel-transition-content"
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          opacity: isHovered || isClicked ? 0 : 1,
          transition: "opacity 0.5s ease",
        }}
      >
        {firstContent}
      </div>
      <div
        className="pixel-transition-content"
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          opacity: isHovered || isClicked ? 1 : 0,
          transition: "opacity 0.5s ease",
        }}
      >
        {secondContent}
      </div>
      {Array.from({ length: gridSize * gridSize }).map((_, i) => (
        <div
          key={i}
          className="pixel-transition-pixel"
          style={{
            width: "100%",
            height: "100%",
            backgroundColor: "transparent",
          }}
        />
      ))}
    </div>
  );
};

export default PixelTransition;


import { useState, useEffect, useRef } from "react";
import { AnimatePresence, motion } from "framer-motion";

const RotatingText = ({
  texts = [],
  rotationInterval = 2000,
  initial = { y: "100%", opacity: 0 },
  animate = { y: 0, opacity: 1 },
  exit = { y: "-120%", opacity: 0 },
  animatePresenceMode = "wait",
  animatePresenceInitial = false,
  staggerDuration = 0,
  staggerFrom = "first",
  transition,
  loop = true,
  auto = true,
  splitBy = "characters",
  onNext,
  mainClassName = "",
  splitLevelClassName = "",
  elementLevelClassName = "",
}) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const intervalRef = useRef(null);

  const defaultTransition = {
    type: "spring",
    damping: 30,
    stiffness: 400,
  };

  const currentTransition = transition || defaultTransition;

  const startRotation = () => {
    intervalRef.current = setInterval(() => {
      setCurrentIndex((prevIndex) => {
        const nextIndex = (prevIndex + 1) % texts.length;
        if (!loop && nextIndex === 0) {
          clearInterval(intervalRef.current);
          return prevIndex;
        }
        if (onNext) onNext(texts[nextIndex]);
        return nextIndex;
      });
    }, rotationInterval);
  };

  useEffect(() => {
    if (auto && texts.length > 1) {
      startRotation();
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [texts, rotationInterval, auto, loop, onNext]);

  const splitText = (text) => {
    if (splitBy === "characters") {
      return text.split("").map((char, i) => (
        <motion.span
          key={char + i}
          initial={initial}
          animate={animate}
          exit={exit}
          transition={{
            ...currentTransition,
            delay: staggerDuration * (staggerFrom === "first" ? i : text.length - 1 - i),
          }}
          className={elementLevelClassName}
        >
          {char === " " ? "\u00A0" : char}
        </motion.span>
      ));
    } else if (splitBy === "words") {
      return text.split(" ").map((word, i) => (
        <motion.span
          key={word + i}
          initial={initial}
          animate={animate}
          exit={exit}
          transition={{
            ...currentTransition,
            delay: staggerDuration * (staggerFrom === "first" ? i : text.split(" ").length - 1 - i),
          }}
          className={elementLevelClassName}
          style={{ display: "inline-block", marginRight: "0.25em" }}
        >
          {word}
        </motion.span>
      ));
    } else if (splitBy === "lines") {
      return text.split("\n").map((line, i) => (
        <motion.span
          key={line + i}
          initial={initial}
          animate={animate}
          exit={exit}
          transition={{
            ...currentTransition,
            delay: staggerDuration * (staggerFrom === "first" ? i : text.split("\n").length - 1 - i),
          }}
          className={elementLevelClassName}
          style={{ display: "block" }}
        >
          {line}
        </motion.span>
      ));
    }
    return (
      <motion.span
        initial={initial}
        animate={animate}
        exit={exit}
        transition={currentTransition}
        className={elementLevelClassName}
      >
        {text}
      </motion.span>
    );
  };

  return (
    <div className={`rotating-text-container ${mainClassName}`}>
      <AnimatePresence mode={animatePresenceMode} initial={animatePresenceInitial}>
        <motion.div
          key={currentIndex}
          className={`rotating-text-item ${splitLevelClassName}`}
          style={{ display: "inline-block", overflow: "hidden" }}
        >
          {splitText(texts[currentIndex])}
        </motion.div>
      </AnimatePresence>
    </div>
  );
};

export default RotatingText;


inside the sandbox

import { useRef, useEffect, useCallback } from "react";
import { gsap } from "gsap";

const ScrambleText = ({
  children,
  radius = 100,
  duration = 1.2,
  speed = 0.5,
  scrambleChars = ".:",
  className = "",
  style = {},
}) => {
  const textRef = useRef(null);
  const charsRef = useRef([]);

  const scramble = useCallback((target) => {
    gsap.to(target, {
      duration: duration,
      scrambleText: {
        text: target.textContent,
        chars: scrambleChars,
        revealDelay: 0.1,
        speed: speed,
        newClass: "scrambled-char",
      },
      ease: "power1.inOut",
    });
  }, [duration, scrambleChars, speed]);

  useEffect(() => {
    if (!textRef.current) return;

    charsRef.current = Array.from(textRef.current.children);

    const handleMouseMove = (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      charsRef.current.forEach((char) => {
        const rect = char.getBoundingClientRect();
        const charX = rect.left + rect.width / 2;
        const charY = rect.top + rect.height / 2;

        const distance = Math.sqrt(
          Math.pow(mouseX - charX, 2) + Math.pow(mouseY - charY, 2)
        );

        if (distance < radius) {
          if (!char._scrambling) {
            char._scrambling = true;
            scramble(char);
            gsap.to(char, { opacity: 1, duration: 0.2 });
          }
        } else {
          if (char._scrambling) {
            char._scrambling = false;
            gsap.to(char, { opacity: 0.7, duration: 0.2 });
          }
        }
      });
    };

    window.addEventListener("mousemove", handleMouseMove);

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
    };
  }, [radius, scramble]);

  return (
    <div ref={textRef} className={`scramble-text-container ${className}`} style={style}>
      {typeof children === "string"
        ? children.split("").map((char, index) => (
            <span key={index} className="scramble-char">
              {char}
            </span>
          ))
        : children}
    </div>
  );
};

export default ScrambleText;


import { useEffect, useMemo, useRef } from "react";
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";

gsap.registerPlugin(ScrollTrigger);

const ScrollFloat = ({
  children,
  scrollContainerRef,
  containerClassName = "",
  textClassName = "",
  animationDuration = 1,
  ease = "back.inOut(2)",
  scrollStart = "center bottom+=50%",
  scrollEnd = "bottom bottom-=40%",
  stagger = 0.03,
}) => {
  const textRef = useRef(null);
  const chars = useMemo(() => {
    if (typeof children === "string") {
      return children.split("");
    }
    return [];
  }, [children]);

  useEffect(() => {
    if (!textRef.current) return;

    const scrollContainer = scrollContainerRef?.current || window;

    gsap.fromTo(
      textRef.current.children,
      {
        y: 100,
        opacity: 0,
      },
      {
        y: 0,
        opacity: 1,
        duration: animationDuration,
        ease: ease,
        stagger: stagger,
        scrollTrigger: {
          trigger: textRef.current,
          start: scrollStart,
          end: scrollEnd,
          scrub: true,
          containerAnimation: scrollContainer,
        },
      }
    );
  }, [children, animationDuration, ease, scrollStart, scrollEnd, stagger, scrollContainerRef]);

  return (
    <div ref={textRef} className={`scroll-float-container ${containerClassName}`}>
      {chars.map((char, index) => (
        <span key={index} className={`scroll-float-char ${textClassName}`}>
          {char === " " ? "\u00A0" : char}
        </span>
      ))}
    </div>
  );
};

export default ScrollFloat;


import { useEffect, useRef, useMemo } from "react";
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";

gsap.registerPlugin(ScrollTrigger);

const ScrollReveal = ({
  children,
  scrollContainerRef,
  enableBlur = true,
  baseOpacity = 0.1,
  baseRotation = 3,
  blurStrength = 4,
  containerClassName = "",
  textClassName = "",
  rotationEnd = "bottom bottom",
  wordAnimationEnd = "bottom bottom",
}) => {
  const containerRef = useRef(null);
  const words = useMemo(() => {
    if (typeof children === "string") {
      return children.split(" ");
    }
    return [];
  }, [children]);

  useEffect(() => {
    if (!containerRef.current) return;

    const scrollContainer = scrollContainerRef?.current || window;

    // Container rotation animation
    gsap.fromTo(
      containerRef.current,
      {
        rotationX: baseRotation,
        rotationY: baseRotation,
        rotationZ: baseRotation,
        transformOrigin: "center center",
      },
      {
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        ease: "none",
        scrollTrigger: {
          trigger: containerRef.current,
          start: "top bottom",
          end: rotationEnd,
          scrub: true,
          containerAnimation: scrollContainer,
        },
      }
    );

    // Word opacity and blur animation
    gsap.fromTo(
      containerRef.current.querySelectorAll(".scroll-reveal-word"),
      {
        opacity: baseOpacity,
        filter: enableBlur ? `blur(${blurStrength}px)` : "none",
      },
      {
        opacity: 1,
        filter: "blur(0px)",
        ease: "none",
        stagger: 0.05,
        scrollTrigger: {
          trigger: containerRef.current,
          start: "top bottom",
          end: wordAnimationEnd,
          scrub: true,
          containerAnimation: scrollContainer,
        },
      }
    );
  }, [children, scrollContainerRef, enableBlur, baseOpacity, baseRotation, blurStrength, rotationEnd, wordAnimationEnd]);

  return (
    <div ref={containerRef} className={`scroll-reveal-container ${containerClassName}`}>
      {words.map((word, index) => (
        <span key={index} className={`scroll-reveal-word ${textClassName}`}>
          {word === " " ? "\u00A0" : word}
        </span>
      ))}
    </div>
  );
};

export default ScrollReveal;


import { useRef, useLayoutEffect, useState } from "react";
import { motion, useScroll, useSpring, useTransform } from "framer-motion";

const ScrollVelocity = ({
  scrollContainerRef,
  texts = [],
  velocity = 100,
  className = "",
  damping = 50,
  stiffness = 400,
  numCopies = 6,
  velocityMapping = { input: [0, 1000], output: [0, 5] },
  parallaxClassName = "parallax",
  scrollerClassName = "scroller",
  parallaxStyle,
  scrollerStyle,
}) => {
  const scrollerRef = useRef(null);
  const [containerWidth, setContainerWidth] = useState(0);

  const { scrollYProgress } = useScroll({
    container: scrollContainerRef,
  });

  const physics = {
    damping,
    stiffness,
    mass: 0.1,
  };

  const x = useSpring(0, physics);
  const xVelocity = useTransform(x, (latest) => {
    const currentVelocity = latest - x.getPrevious();
    return currentVelocity;
  });

  const mappedVelocity = useTransform(
    xVelocity,
    velocityMapping.input,
    velocityMapping.output
  );

  useLayoutEffect(() => {
    if (!scrollerRef.current) return;

    const updateWidth = () => {
      setContainerWidth(scrollerRef.current.scrollWidth);
    };

    updateWidth();
    window.addEventListener("resize", updateWidth);

    return () => {
      window.removeEventListener("resize", updateWidth);
    };
  }, [texts, numCopies]);

  useEffect(() => {
    const unsubscribeScroll = scrollYProgress.onChange((latest) => {
      const newX = latest * containerWidth;
      x.set(newX);
    });

    return () => {
      unsubscribeScroll();
    };
  }, [scrollYProgress, containerWidth, x]);

  return (
    <div
      className={`scroll-velocity-parallax ${parallaxClassName}`}
      style={parallaxStyle}
    >
      <motion.div
        className={`scroll-velocity-scroller ${scrollerClassName}`}
        ref={scrollerRef}
        style={{
          x,
          display: "flex",
          whiteSpace: "nowrap",
          willChange: "transform",
          ...scrollerStyle,
        }}
      >
        {Array.from({ length: numCopies }).map((_, copyIndex) => (
          <motion.span
            key={copyIndex}
            className={`scroll-velocity-text ${className}`}
            style={{
              x: useTransform(
                mappedVelocity,
                (v) => v * (copyIndex % 2 === 0 ? 1 : -1) * velocity
              ),
              display: "inline-block",
            }}
          >
            {texts.join(" ")}
          </motion.span>
        ))}
      </motion.div>
    </div>
  );
};

export default ScrollVelocity;


import "./ShinyText.css";

const ShinyText = ({ text, disabled = false, speed = 5, className = "" }) => {
  const animationDuration = `${speed}s`;

  return (
    <div
      className={`shiny-text ${disabled ? "disabled" : ""} ${className}`}
      style={{ animationDuration }}
    >
      {text}
    </div>
  );
};

export default ShinyText;


import { useRef, useEffect, useState } from "react";
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import { SplitText as GSAPSplitText } from "gsap/SplitText";
import { useGSAP } from "@gsap/react";

gsap.registerPlugin(ScrollTrigger, GSAPSplitText, useGSAP);

const SplitText = ({
  text,
  className = "",
  delay = 100,
  duration = 0.6,
  ease = "power3.out",
  splitType = "chars",
  from = { opacity: 0, y: 40 },
  to = { opacity: 1, y: 0 },
  threshold = 0.1,
  rootMargin = "-100px",
  textAlign = "center",
  tag = "p",
  onLetterAnimationComplete,
}) => {
  const ref = useRef(null);
  const animationCompletedRef = useRef(false);
  const [fontsLoaded, setFontsLoaded] = useState(false);

  useEffect(() => {
    if (document.fonts.status === "loaded") {
      setFontsLoaded(true);
    } else {
      document.fonts.ready.then(() => {
        setFontsLoaded(true);
      });
    }
  }, []);

  useGSAP(
    () => {
      if (!ref.current || !text || !fontsLoaded) return;
      const el = ref.current;

      if (el._rbsplitInstance) {
        try {
          el._rbsplitInstance.revert();
        } catch (_) { /* noop */ }
        el._rbsplitInstance = null;
      }

      const startPct = (1 - threshold) * 100;
      const marginMatch = /^(-?\d+(?:\.\d+)?)(px|em|rem|%)?$/.exec(rootMargin);
      const marginValue = marginMatch ? parseFloat(marginMatch[1]) : 0;
      const marginUnit = marginMatch ? marginMatch[2] || "px" : "px";
      const sign = marginValue === 0 ? "" : (marginValue < 0
        ? `-=${Math.abs(marginValue)}${marginUnit}`
        : `+=${marginValue}${marginUnit}`);
      const start = `top ${startPct}%${sign}`;

      let targets;
      const assignTargets = (self) => {
        if (splitType.includes("chars") && self.chars.length) targets = self.chars;
        if (!targets && splitType.includes("words") && self.words.length) targets = self.words;
        if (!targets && splitType.includes("lines") && self.lines.length) targets = self.lines;
        if (!targets) targets = self.chars || self.words || self.lines;
      };

      const splitInstance = new GSAPSplitText(el, {
        type: splitType,
        smartWrap: true,
        autoSplit: splitType === "lines",
        linesClass: "split-line",
        wordsClass: "split-word",
        charsClass: "split-char",
        reduceWhiteSpace: false,
        onSplit: (self) => {
          assignTargets(self);
          const tween = gsap.fromTo(
            targets,
            { ...from },
            {
              ...to,
              duration,
              ease,
              stagger: delay / 1000,
              scrollTrigger: {
                trigger: el,
                start,
                once: true,
                fastScrollEnd: true,
                anticipatePin: 0.4,
              },
              onComplete: () => {
                animationCompletedRef.current = true;
                onLetterAnimationComplete?.();
              },
              willChange: "transform, opacity",
              force3D: true,
            }
          );
          return tween;
        },
      });

      el._rbsplitInstance = splitInstance;

      return () => {
        ScrollTrigger.getAll().forEach((st) => {
          if (st.trigger === el) st.kill();
        });
        try {
          splitInstance.revert();
        } catch (_) { /* noop */ }
        el._rbsplitInstance = null;
      };
    },
    {
      dependencies: [
        text,
        delay,
        duration,
        ease,
        splitType,
        JSON.stringify(from),
        JSON.stringify(to),
        threshold,
        rootMargin,
        fontsLoaded,
        onLetterAnimationComplete,
      ],
      scope: ref,
    }
  );

  const renderTag = () => {
    const style = {
      textAlign,
      overflow: "hidden",
      display: "inline-block",
      whiteSpace: "normal",
      wordWrap: "break-word",
      willChange: "transform, opacity",
    };
    const classes = `split-parent ${className}`;
    switch (tag) {
      case "h1":
        return (
          <h1 ref={ref} style={style} className={classes}>
            {text}
          </h1>
        );
      case "h2":
        return (
          <h2 ref={ref} style={style} className={classes}>
            {text}
          </h2>
        );
      case "h3":
        return (
          <h3 ref={ref} style={style} className={classes}>
            {text}
          </h3>
        );
      case "h4":
        return (
          <h4 ref={ref} style={style} className={classes}>
            {text}
          </h4>
        );
      case "h5":
        return (
          <h5 ref={ref} style={style} className={classes}>
            {text}
          </h5>
        );
      case "h6":
        return (
          <h6 ref={ref} style={style} className={classes}>
            {text}
          </h6>
        );
      default:
        return (
          <p ref={ref} style={style} className={classes}>
            {text}
          </p>
        );
    }
  };
  return renderTag();
};

export default SplitText;


import { useState, useEffect, useRef } from "react";
import { motion, useAnimate } from "framer-motion";

const TextCursor = ({
  text = "⚛️",
  delay = 0.01,
  spacing = 100,
  followMouseDirection = true,
  randomFloat = true,
  exitDuration = 0.5,
  removalInterval = 30,
  maxPoints = 5,
}) => {
  const [points, setPoints] = useState([]);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const lastMousePosition = useRef({ x: 0, y: 0 });
  const timeoutRef = useRef(null);
  const intervalRef = useRef(null);

  const [scope, animate] = useAnimate();

  const handleMouseMove = (e) => {
    setMousePosition({ x: e.clientX, y: e.clientY });
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => {
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(() => {
        setPoints((prevPoints) => {
          if (prevPoints.length === 0) {
            clearInterval(intervalRef.current);
            return [];
          }
          return prevPoints.slice(1);
        });
      }, removalInterval);
    }, 100);
  };

  useEffect(() => {
    window.addEventListener("mousemove", handleMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      clearTimeout(timeoutRef.current);
      clearInterval(intervalRef.current);
    };
  }, []);

  useEffect(() => {
    const distance = Math.sqrt(
      Math.pow(mousePosition.x - lastMousePosition.current.x, 2) +
      Math.pow(mousePosition.y - lastMousePosition.current.y, 2)
    );

    if (distance > spacing) {
      setPoints((prevPoints) => {
        const newPoints = [
          ...prevPoints.slice(Math.max(0, prevPoints.length - maxPoints + 1)),
          { id: Date.now(), position: mousePosition, rotation: 0 },
        ];

        if (followMouseDirection && newPoints.length > 1) {
          const lastPoint = newPoints[newPoints.length - 1];
          const secondLastPoint = newPoints[newPoints.length - 2];
          const angle =
            Math.atan2(
              lastPoint.position.y - secondLastPoint.position.y,
              lastPoint.position.x - secondLastPoint.position.x
            ) * (180 / Math.PI);
          lastPoint.rotation = angle;
        }

        return newPoints;
      });
      lastMousePosition.current = mousePosition;
    }
  }, [mousePosition, spacing, followMouseDirection, maxPoints]);

  useEffect(() => {
    points.forEach((point) => {
      const element = scope.current.querySelector(`#point-${point.id}`);
      if (element) {
        const xOffset = randomFloat ? (Math.random() - 0.5) * 20 : 0;
        const yOffset = randomFloat ? (Math.random() - 0.5) * 20 : 0;
        const rotateOffset = randomFloat ? (Math.random() - 0.5) * 30 : 0;

        animate(
          element,
          {
            x: point.position.x + xOffset,
            y: point.position.y + yOffset,
            rotate: point.rotation + rotateOffset,
            opacity: [0, 1],
            scale: [0.5, 1],
          },
          {
            duration: 0.5,
            ease: "easeOut",
            delay: delay,
          }
        );

        animate(
          element,
          {
            opacity: 0,
            scale: 0,
          },
          {
            duration: exitDuration,
            ease: "easeIn",
            delay: 0.5 + delay, // Start fading out after initial animation
          }
        );
      }
    });
  }, [points, animate, delay, randomFloat, exitDuration, scope]);

  return (
    <div
      ref={scope}
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        overflow: "hidden",
        zIndex: 9999,
      }}
    >
      {points.map((point) => (
        <motion.div
          key={point.id}
          id={`point-${point.id}`}
          style={{
            position: "absolute",
            x: -50,
            y: -50,
            fontSize: "2rem",
            whiteSpace: "nowrap",
          }}
        >
          {text}
        </motion.div>
      ))}
    </div>
  );
};

export default TextCursor;


import { useEffect, useRef, useState, useCallback } from "react";
import { gsap } from "gsap";
import { useGSAP } from "@gsap/react";

gsap.registerPlugin(useGSAP);

const TextPressure = ({
  text = "Hello!",
  fontFamily,
  fontUrl,
  flex = true,
  scale = false,
  alpha = false,
  stroke = false,
  width = true,
  weight = true,
  italic = true,
  textColor = "#FFFFFF",
  strokeColor = "#FF0000",
  className = "",
  minFontSize = 24,
}) => {
  const containerRef = useRef(null);
  const [isFontLoaded, setIsFontLoaded] = useState(false);

  useEffect(() => {
    if (!fontUrl) {
      setIsFontLoaded(true);
      return;
    }

    const fontFace = new FontFace(fontFamily, `url(${fontUrl})`);
    fontFace.load().then(() => {
      document.fonts.add(fontFace);
      setIsFontLoaded(true);
    });
  }, [fontFamily, fontUrl]);

  useGSAP(
    () => {
      if (!containerRef.current || !isFontLoaded) return;

      const chars = containerRef.current.querySelectorAll("span");

      const handleMouseMove = (e) => {
        const containerRect = containerRef.current.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;

        chars.forEach((char) => {
          const charRect = char.getBoundingClientRect();
          const charX = charRect.left - containerRect.left + charRect.width / 2;
          const charY = charRect.top - containerRect.top + charRect.height / 2;

          const distance = Math.sqrt(
            Math.pow(mouseX - charX, 2) + Math.pow(mouseY - charY, 2)
          );

          const maxDistance = Math.sqrt(
            Math.pow(containerRect.width / 2, 2) +
            Math.pow(containerRect.height / 2, 2)
          );

          const normalizedDistance = Math.min(1, distance / maxDistance);

          const fontVariationSettings = {};
          if (width) {
            fontVariationSettings.wght = gsap.utils.mapRange(
              0, 1, 900, 100, normalizedDistance
            );
          }
          if (weight) {
            fontVariationSettings.wdth = gsap.utils.mapRange(
              0, 1, 150, 50, normalizedDistance
            );
          }
          if (italic) {
            fontVariationSettings.ital = gsap.utils.mapRange(
              0, 1, 1, 0, normalizedDistance
            );
          }

          gsap.to(char, {
            duration: 0.5,
            fontVariationSettings: Object.entries(fontVariationSettings)
              .map(([key, value]) => `'${key}' ${value}`)
              .join(", "),
            opacity: alpha ? 1 - normalizedDistance : 1,
            scale: scale ? 1 + (1 - normalizedDistance) * 0.5 : 1,
            ease: "power2.out",
          });
        });
      };

      containerRef.current.addEventListener("mousemove", handleMouseMove);

      return () => {
        if (containerRef.current) {
          containerRef.current.removeEventListener("mousemove", handleMouseMove);
        }
      };
    },
    { scope: containerRef, dependencies: [isFontLoaded] }
  );

  const renderText = useCallback(() => {
    return text.split("").map((char, index) => (
      <span
        key={index}
        style={{
          display: flex ? "inline-block" : "inline",
          color: textColor,
          fontSize: `${minFontSize}px`,
          ...(stroke && {
            WebkitTextStroke: `1px ${strokeColor}`,
            WebkitTextFillColor: textColor,
          }),
        }}
      >
        {char === " " ? "\u00A0" : char}
      </span>
    ));
  }, [text, flex, textColor, stroke, strokeColor, minFontSize]);

  return (
    <h1
      ref={containerRef}
      className={`text-pressure-container ${className}`}
      style={{
        fontFamily: fontFamily || "sans-serif",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        overflow: "hidden",
        position: "relative",
        width: "100%",
        height: "100%",
      }}
    >
      {isFontLoaded ? renderText() : text}
    </h1>
  );
};

export default TextPressure;


import { useEffect, useRef, useState, useCallback } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader";

const TextTrail = ({
  text = "Trail",
  fontFamily = "Figtree",
  fontWeight = "900",
  noiseFactor = 1,
  noiseScale = 0.0005,
  rgbPersistFactor = 0.98,
  alphaPersistFactor = 0.95,
  animateColor = false,
  startColor = "#ffffff",
  textColor = "#ffffff",
  backgroundColor = 0x271e37,
  colorCycleInterval = 3000,
  supersample = 2,
}) => {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const textMeshRef = useRef(null);
  const controlsRef = useRef(null);
  const textureRef = useRef(null);
  const materialRef = useRef(null);
  const fontRef = useRef(null);
  const animateRef = useRef(null);

  const [currentTextColor, setCurrentTextColor] = useState(new THREE.Color(startColor));

  const loadFont = useCallback(() => {
    const loader = new FontLoader();
    loader.load(
      `https://fonts.googleapis.com/css2?family=${fontFamily}:wght@${fontWeight}&display=swap`,
      (font) => {
        fontRef.current = font;
        initScene();
      },
      undefined,
      (error) => {
        console.error("Error loading font:", error);
      }
    );
  }, [fontFamily, fontWeight]);

  const initScene = useCallback(() => {
    if (!mountRef.current || !fontRef.current) return;

    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    // Scene
    const scene = new THREE.Scene();
    sceneRef.current = scene;

    // Camera
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 5;
    cameraRef.current = camera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas: mountRef.current,
      alpha: true,
      antialias: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio * supersample);
    renderer.setClearColor(backgroundColor, 1);
    rendererRef.current = renderer;

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controlsRef.current = controls;

    // Text
    const textGeometry = new TextGeometry(text, {
      font: fontRef.current,
      size: 1,
      height: 0.2,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.03,
      bevelSize: 0.02,
      bevelOffset: 0,
      bevelSegments: 5,
    });
    textGeometry.center();

    const textMaterial = new THREE.MeshBasicMaterial({ color: currentTextColor });
    materialRef.current = textMaterial;

    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    scene.add(textMesh);
    textMeshRef.current = textMesh;

    // Trail effect setup
    const trailCanvas = document.createElement("canvas");
    trailCanvas.width = width;
    trailCanvas.height = height;
    const trailCtx = trailCanvas.getContext("2d");
    trailCtx.fillStyle = `rgba(${new THREE.Color(backgroundColor).r * 255}, ${new THREE.Color(backgroundColor).g * 255}, ${new THREE.Color(backgroundColor).b * 255}, 1)`;
    trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);

    const trailTexture = new THREE.CanvasTexture(trailCanvas);
    textureRef.current = trailTexture;

    const trailMaterial = new THREE.MeshBasicMaterial({
      map: trailTexture,
      transparent: true,
    });
    const planeGeometry = new THREE.PlaneGeometry(width / 100, height / 100);
    const plane = new THREE.Mesh(planeGeometry, trailMaterial);
    plane.position.z = -1;
    scene.add(plane);

    const updateTrail = () => {
      trailCtx.globalCompositeOperation = "source-over";
      trailCtx.fillStyle = `rgba(${new THREE.Color(backgroundColor).r * 255}, ${new THREE.Color(backgroundColor).g * 255}, ${new THREE.Color(backgroundColor).b * 255}, ${1 - alphaPersistFactor})`;
      trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);

      trailCtx.globalCompositeOperation = "lighter";
      renderer.render(scene, camera);
      trailCtx.drawImage(renderer.domElement, 0, 0);
      trailTexture.needsUpdate = true;
    };

    const animate = () => {
      requestAnimationFrame(animate);

      controls.update();

      if (animateColor) {
        const hue = (Date.now() % colorCycleInterval) / colorCycleInterval;
        currentTextColor.setHSL(hue, 1, 0.5);
        textMaterial.color.copy(currentTextColor);
      }

      // Apply noise to text mesh
      if (textMesh.geometry.attributes.position) {
        const positions = textMesh.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          const z = positions[i + 2];

          const noiseX = (Math.sin(x * noiseScale + Date.now() * 0.001) * noiseFactor);
          const noiseY = (Math.cos(y * noiseScale + Date.now() * 0.001) * noiseFactor);
          const noiseZ = (Math.sin(z * noiseScale + Date.now() * 0.001) * noiseFactor);

          positions[i] = x + noiseX;
          positions[i + 1] = y + noiseY;
          positions[i + 2] = z + noiseZ;
        }
        textMesh.geometry.attributes.position.needsUpdate = true;
      }

      updateTrail();
    };
    animateRef.current = animate;
    animate();

    const handleResize = () => {
      const newWidth = mountRef.current.clientWidth;
      const newHeight = mountRef.current.clientHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      trailCanvas.width = newWidth;
      trailCanvas.height = newHeight;
      trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
      trailTexture.needsUpdate = true;
    };

    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      renderer.dispose();
      controls.dispose();
      if (animateRef.current) {
        cancelAnimationFrame(animateRef.current);
      }
    };
  }, [text, backgroundColor, noiseFactor, noiseScale, rgbPersistFactor, alphaPersistFactor, animateColor, startColor, textColor, colorCycleInterval, supersample, currentTextColor]);

  useEffect(() => {
    loadFont();
  }, [loadFont]);

  return <div ref={mountRef} style={{ width: "100%", height: "100vh" }} />;
};

export default TextTrail;


import { useEffect, useRef, useState, createElement, useMemo, useCallback } from "react";
import { gsap } from "gsap";
import { TextPlugin } from "gsap/TextPlugin";

gsap.registerPlugin(TextPlugin);

const TextType = ({
  text = [],
  as: Component = "div",
  typingSpeed = 50,
  initialDelay = 0,
  pauseDuration = 2000,
  deletingSpeed = 30,
  loop = true,
  className = "",
  showCursor = true,
  hideCursorWhileTyping = false,
  cursorCharacter = "|",
  cursorBlinkDuration = 0.5,
  cursorClassName = "",
  textColors = [],
  variableSpeed,
  onSentenceComplete,
  startOnVisible = false,
  reverseMode = false,
}) => {
  const el = useRef(null);
  const cursor = useRef(null);
  const [currentText, setCurrentText] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [sentenceIndex, setSentenceIndex] = useState(0);
  const [charIndex, setCharIndex] = useState(0);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isVisible, setIsVisible] = useState(!startOnVisible);

  const sentences = useMemo(
    () => (Array.isArray(text) ? text : [text]),
    [text]
  );

  const currentSentence = sentences[sentenceIndex];

  const getTypingSpeed = useCallback(() => {
    if (variableSpeed) {
      return (
        Math.random() * (variableSpeed.max - variableSpeed.min) +
        variableSpeed.min
      );
    }
    return typingSpeed;
  }, [typingSpeed, variableSpeed]);

  const getDeletingSpeed = useCallback(() => {
    if (variableSpeed) {
      return (
        Math.random() * (variableSpeed.max - variableSpeed.min) +
        variableSpeed.min
      );
    }
    return deletingSpeed;
  }, [deletingSpeed, variableSpeed]);

  useEffect(() => {
    if (startOnVisible) {
      const observer = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            setIsVisible(true);
            observer.disconnect();
          }
        },
        { threshold: 0.1 }
      );
      if (el.current) {
        observer.observe(el.current);
      }
      return () => {
        observer.disconnect();
      };
    }
  }, [startOnVisible]);

  useEffect(() => {
    if (!isVisible) return;

    const type = () => {
      setIsTyping(true);
      const speed = reverseMode ? getDeletingSpeed() : getTypingSpeed();
      const targetText = reverseMode ? "" : currentSentence;
      const startChar = reverseMode ? currentSentence.length : 0;
      const endChar = reverseMode ? 0 : currentSentence.length;

      gsap.to(el.current, {
        duration: (Math.abs(endChar - startChar) * speed) / 1000,
        text: {
          value: targetText,
          speed: 1,
          delimiter: "",
        },
        ease: "none",
        onUpdate: () => {
          setCurrentText(el.current.innerText);
        },
        onComplete: () => {
          setIsTyping(false);
          if (!reverseMode) {
            onSentenceComplete?.(currentSentence, sentenceIndex);
          }
          if (loop || sentenceIndex < sentences.length - 1) {
            setTimeout(() => {
              setIsDeleting(true);
              const deleteSpeed = getDeletingSpeed();
              gsap.to(el.current, {
                duration: (currentSentence.length * deleteSpeed) / 1000,
                text: {
                  value: "",
                  speed: 1,
                  delimiter: "",
                },
                ease: "none",
                onUpdate: () => {
                  setCurrentText(el.current.innerText);
                },
                onComplete: () => {
                  setIsDeleting(false);
                  setSentenceIndex(
                    (prevIndex) => (prevIndex + 1) % sentences.length
                  );
                },
              });
            }, pauseDuration);
          } else if (cursor.current) {
            gsap.to(cursor.current, { opacity: 0, repeat: -1, yoyo: true, duration: cursorBlinkDuration });
          }
        },
      });
    };

    const startTyping = () => {
      if (initialDelay > 0) {
        setTimeout(type, initialDelay);
      } else {
        type();
      }
    };

    startTyping();
  }, [
    currentSentence,
    sentences,
    loop,
    initialDelay,
    pauseDuration,
    getTypingSpeed,
    getDeletingSpeed,
    onSentenceComplete,
    cursorBlinkDuration,
    isVisible,
    reverseMode,
  ]);

  useEffect(() => {
    if (cursor.current) {
      if (hideCursorWhileTyping && isTyping) {
        gsap.to(cursor.current, { opacity: 0, duration: 0.1 });
      } else {
        gsap.to(cursor.current, { opacity: 1, repeat: -1, yoyo: true, duration: cursorBlinkDuration });
      }
    }
  }, [hideCursorWhileTyping, isTyping, cursorBlinkDuration]);

  const textColor = textColors[sentenceIndex] || "inherit";

  return createElement(
    Component,
    { className: `text-type-container ${className}` },
    <span ref={el} style={{ color: textColor }}>
      {currentText}
    </span>,
    showCursor && (
      <span
        ref={cursor}
        className={`text-type-cursor ${cursorClassName}`}
        style={{ display: "inline-block", verticalAlign: "middle" }}
      >
        {cursorCharacter}
      </span>
    )
  );
};

export default TextType;


import { useEffect, useRef, useState } from "react";
import { motion } from "framer-motion";
import "./TrueFocus.css";

const TrueFocus = ({
  sentence = "True Focus",
  manualMode = false,
  blurAmount = 5,
  borderColor = "green",
  glowColor = "rgba(0, 255, 0, 0.6)",
  animationDuration = 0.5,
  pauseBetweenAnimations = 1,
}) => {
  const words = sentence.split(" ");
  const [activeWordIndex, setActiveWordIndex] = useState(0);
  const [isHovered, setIsHovered] = useState(false);
  const timeoutRef = useRef(null);

  useEffect(() => {
    if (manualMode) return;

    const animateWords = () => {
      setActiveWordIndex((prevIndex) => (prevIndex + 1) % words.length);
      timeoutRef.current = setTimeout(
        animateWords,
        (animationDuration + pauseBetweenAnimations) * 1000
      );
    };

    timeoutRef.current = setTimeout(
      animateWords,
      (animationDuration + pauseBetweenAnimations) * 1000
    );

    return () => clearTimeout(timeoutRef.current);
  }, [words.length, manualMode, animationDuration, pauseBetweenAnimations]);

  const handleMouseEnter = (index) => {
    if (manualMode) {
      setActiveWordIndex(index);
      setIsHovered(true);
    }
  };

  const handleMouseLeave = () => {
    if (manualMode) {
      setIsHovered(false);
    }
  };

  return (
    <div className="true-focus-container">
      {words.map((word, index) => (
        <motion.span
          key={index}
          className="true-focus-word"
          onMouseEnter={() => handleMouseEnter(index)}
          onMouseLeave={handleMouseLeave}
          animate={{
            filter: activeWordIndex === index && !isHovered ? "blur(0px)" : `blur(${blurAmount}px)`,
            color: activeWordIndex === index && !isHovered ? "inherit" : "gray",
            borderColor: activeWordIndex === index && !isHovered ? borderColor : "transparent",
            boxShadow: activeWordIndex === index && !isHovered ? `0 0 15px ${glowColor}` : "none",
          }}
          transition={{ duration: animationDuration }}
        >
          {word}
        </motion.span>
      ))}
    </div>
  );
};

export default TrueFocus;


import { useRef, useEffect, useState, useCallback } from "react";
import { motion, useSpring, useTransform } from "framer-motion";

const VariableProximity = ({
  label,
  fromFontVariationSettings = "\"wght\" 400, \"opsz\" 9",
  toFontVariationSettings = "\"wght\" 800, \"opsz\" 40",
  containerRef,
  radius = 50,
  falloff = "linear",
}) => {
  const textRef = useRef(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = useCallback((e) => {
    setMousePosition({ x: e.clientX, y: e.clientY });
  }, []);

  useEffect(() => {
    const currentContainer = containerRef?.current || document.body;
    currentContainer.addEventListener("mousemove", handleMouseMove);

    return () => {
      currentContainer.removeEventListener("mousemove", handleMouseMove);
    };
  }, [containerRef, handleMouseMove]);

  const getProximity = useCallback(() => {
    if (!textRef.current || !containerRef.current) return 0;

    const textRect = textRef.current.getBoundingClientRect();
    const containerRect = containerRef.current.getBoundingClientRect();

    const textCenterX = textRect.left + textRect.width / 2;
    const textCenterY = textRect.top + textRect.height / 2;

    const mouseX = mousePosition.x;
    const mouseY = mousePosition.y;

    const distance = Math.sqrt(
      Math.pow(mouseX - textCenterX, 2) + Math.pow(mouseY - textCenterY, 2)
    );

    let proximity = 0;
    if (distance < radius) {
      proximity = 1 - distance / radius;

      if (falloff === "exponential") {
        proximity = Math.pow(proximity, 2);
      } else if (falloff === "gaussian") {
        proximity = Math.exp(-(distance * distance) / (2 * radius * radius));
      }
    }
    return proximity;
  }, [mousePosition, radius, falloff, containerRef]);

  const proximity = useSpring(0, { stiffness: 100, damping: 20 });

  useEffect(() => {
    proximity.set(getProximity());
  }, [getProximity, proximity]);

  const fontVariationSettings = useTransform(
    proximity,
    [0, 1],
    [fromFontVariationSettings, toFontVariationSettings]
  );

  return (
    <motion.span
      ref={textRef}
      style={{
        fontVariationSettings,
        display: "inline-block",
        willChange: "font-variation-settings",
      }}
    >
      {label}
    </motion.span>
  );
};

export default VariableProximity;


